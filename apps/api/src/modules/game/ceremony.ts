import { buildNpcRegistry, MAX_ACTIVE_NPCS } from '@mls/shared/npc-registry';
import type { CeremonyPlayerAward, CeremonyReport } from '@mls/shared/game-types';
import type { DbGameStateRow } from './repo.js';

const MEDALS = ['Distinguished Service Medal', 'Meritorious Service Medal', 'Combat Readiness Medal', 'Joint Commendation Medal', 'Leadership Ribbon'];

function ceremonyDay(gameDay: number): number {
  if (gameDay < 12) return 12;
  return Math.floor(gameDay / 12) * 12;
}

function scoreNpc(ceremonyDayValue: number, slot: number, morale: number, health: number): number {
  const growth = Math.floor(ceremonyDayValue / 3);
  const personality = (slot * 17 + ceremonyDayValue * 7) % 35;
  return 45 + growth + personality + Math.floor((morale + health) / 12);
}


export function isPlayerAwardedOnCeremony(state: DbGameStateRow): boolean {
  return (state.rank_index + state.morale + state.health + state.current_day) % 2 === 0;
}

export function getPlayerCeremonyAward(state: DbGameStateRow, recipients: CeremonyReport['recipients']): CeremonyPlayerAward | null {
  if (!isPlayerAwardedOnCeremony(state)) return null;
  const baseMedal = recipients[0]?.medalName ?? 'Distinguished Service Medal';
  const baseRibbon = recipients[0]?.ribbonName ?? 'Ribbon-1';
  return {
    playerName: state.player_name,
    medalName: baseMedal,
    ribbonName: baseRibbon,
    reason: 'Nominasi Chief of Staff berdasarkan konsistensi KPI komando pada siklus upacara saat ini.'
  };
}

export function buildCeremonyReport(state: DbGameStateRow): CeremonyReport {
  const currentCeremonyDay = ceremonyDay(state.current_day);
  const previousCeremonyDay = Math.max(12, currentCeremonyDay - 12);
  const registry = buildNpcRegistry(state.branch, MAX_ACTIVE_NPCS);

  const ranked = registry
    .map((npc) => ({
      ...npc,
      competenceScore: scoreNpc(currentCeremonyDay, npc.slot, state.morale, state.health)
    }))
    .sort((a, b) => b.competenceScore - a.competenceScore);

  const previousRanked = registry
    .map((npc) => ({
      ...npc,
      competenceScore: scoreNpc(previousCeremonyDay, npc.slot, state.morale, state.health)
    }))
    .sort((a, b) => b.competenceScore - a.competenceScore);

  const chief = ranked[0];
  const previousChief = previousRanked[0];
  const quota = Math.max(2, Math.min(8, Math.round(chief.competenceScore / 23 + state.morale / 30)));
  const recipients = ranked.slice(1, quota + 1).map((npc, idx) => ({
    order: idx + 1,
    npcName: npc.name,
    division: npc.division,
    unit: npc.unit,
    position: npc.position,
    medalName: MEDALS[idx % MEDALS.length],
    ribbonName: `Ribbon-${(idx % 5) + 1}`,
    reason: `Performance score ${npc.competenceScore} with sustained readiness and leadership impact.`
  }));

  const playerAward = getPlayerCeremonyAward(state, recipients);
  const logs = [
    `Ceremony starts on Day ${currentCeremonyDay}. All ${MAX_ACTIVE_NPCS + 1} personnel are assembled for formation and readiness brief.`,
    `Chief of Staff ${chief.name} opens the ceremony and confirms medal quota (${quota}) generated by command AI.`,
    'Medal ribbon session is executed sequentially, one recipient at a time, with live command log updates.',
    playerAward
      ? `Player ${playerAward.playerName} receives ${playerAward.medalName} with ${playerAward.ribbonName} in this ceremony cycle.`
      : `Player ${state.player_name} is not selected for medal ribbon this cycle and remains on active evaluation track.`,
    'Ceremony closes with branch-wide directives for next 12-day operational cycle.'
  ];

  return {
    ceremonyDay: currentCeremonyDay,
    attendance: MAX_ACTIVE_NPCS + 1,
    medalQuota: quota,
    chiefOfStaff: {
      name: chief.name,
      competenceScore: chief.competenceScore,
      previousChiefName: previousChief?.name ?? null,
      replacedPreviousChief: Boolean(previousChief && previousChief.name !== chief.name)
    },
    logs,
    recipients,
    playerAward
  };
}
